const TelegramBot = require('node-telegram-bot-api');
// Import the xlsx library
const XLSX = require("xlsx");
const fs = require("fs");

// Replace with your bot token
const token = '7469831778:AAGtktOKYRA0tG6DzfF1A4u9weAnKHShZPk';

// Create a bot instance
const bot = new TelegramBot(token, { polling: true });

// Create an object to store user data
const userData = {};

// Create an object to keep track of units for each user
const userUnits = {};


// Create an object to track the current keyboard for each user
const currentKeyboards = {};

rooms = [["living_room", "ğŸ›‹ï¸ Ù¾Ø°ÛŒØ±Ø§ÛŒÛŒ"],
        ["kitchen", "ğŸ½ï¸ Ø¢Ø´Ù¾Ø²Ø®Ø§Ù†Ù‡"],
        ["bedroom_1", "ğŸ›ï¸ Ø§ØªØ§Ù‚ Ø®ÙˆØ§Ø¨ 1"],
        ["bedroom_2", "ğŸ›ï¸ Ø§ØªØ§Ù‚ Ø®ÙˆØ§Ø¨ 2"],
        ["bedroom_3", "ğŸ›ï¸ Ø§ØªØ§Ù‚ Ø®ÙˆØ§Ø¨ 3"],
        ["bedroom_4", "ğŸ›ï¸ Ø§ØªØ§Ù‚ Ø®ÙˆØ§Ø¨ 4"],
        ["bedroom_5", "ğŸ›ï¸ Ø§ØªØ§Ù‚ Ø®ÙˆØ§Ø¨ 5"],
        ["toilet_1", "ğŸš½ Ø³Ø±ÙˆÛŒØ³ Ø¨Ù‡Ø¯Ø§Ø´ØªÛŒ 1"],
        ["toilet_2", "ğŸš½ Ø³Ø±ÙˆÛŒØ³ Ø¨Ù‡Ø¯Ø§Ø´ØªÛŒ 2"],
    ]


  // Function to handle user input for the value
bot.on('message', (msg) => {
const chatId = msg.chat.id;
const text = msg.text;


if(text == "/start" || text == "Ø´Ø±ÙˆØ¹ Ù…Ø¬Ø¯Ø¯"){
    userUnits[chatId] = []
    userData[chatId] = []
    save_user_information(msg)


        const keyboard = {
        reply_markup: {
            keyboard: [
                ['Ø´Ø±ÙˆØ¹ Ù…Ø¬Ø¯Ø¯'], // First row with one button
                ['Ø®Ø±ÙˆØ¬ÛŒ Ø§Ú©Ø³Ù„']  // Second row with another button
            ],
            resize_keyboard: true, // Optional: resize the keyboard to fit
            one_time_keyboard: true // Optional: hide the keyboard after a button is pressed
        }
    };
    bot.sendMessage(chatId, 'ğŸ”µğŸ”µğŸ”µ*Ø±Ø¨Ø§Øª ØªÙ„Ú¯Ø±Ø§Ù…ÛŒ Ù†Ø¸Ø§Ù… Ù…Ù‡Ù†Ø¯Ø³ÛŒ*ğŸ”µğŸ”µğŸ”µ', keyboard);

    setTimeout(()=>{askOwnerName(chatId);}, 500)
} 
else if (userData[chatId].currentStep === 'enter_con_value') {
  userUnits[chatId][userData[chatId].currentUnit].rooms[userData[chatId].currentRoom].sockets[userData[chatId].currentSocket].con = text;
  userUnits[chatId][userData[chatId].currentUnit].rooms[userData[chatId].currentRoom].sockets.push({"pol" : NaN, "con" : NaN, "rcd": NaN, "loop" : NaN})
  handle_socket_selection(parseInt(userData[chatId].currentSocket) + 1, chatId)
}else if(text == "/output" || text == 'Ø®Ø±ÙˆØ¬ÛŒ Ø§Ú©Ø³Ù„'){
    // Generate the Excel data
  console.log(userUnits[chatId][userData[chatId].currentUnit].rooms[userData[chatId].currentRoom].sockets)
  const excelData = jsonToExcelData(userUnits[chatId]);

  // Create a new workbook and add the data to a worksheet
  const worksheet = XLSX.utils.json_to_sheet(excelData);
  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, "Units");

  // Write the workbook to a file
  console.log(userData[chatId].ownerName)

  file_name = "output_" + userData[chatId].ownerName + "_" +  Date.now()
  excel_file = file_name + ".xlsx"

  XLSX.writeFile(workbook, excel_file);

  console.log("Excel file created successfully.");

   // Send the PDF to the user
  
  // Send the file to the user
  bot.sendDocument(chatId, excel_file).then(() => {
      // Clean up the file after sending
      fs.unlinkSync(excel_file);
  }).catch((error) => {
      console.error('Error sending the file:', error);
  });

}
});
  

// Function to handle callback queries
bot.on('callback_query', (callbackQuery) => {
    const chatId = callbackQuery.message.chat.id;
    const data = callbackQuery.data;
  
  if (data.startsWith('unit_')) {
    z = data.split('_')[1] - 1;
    handleUnitSelection(chatId, z);
  } else if(data == "return_to_room_selection"){
    handleUnitSelection(chatId, userData[chatId].currentUnit)
  } else if (data === 'return_to_units') {
    showUnitsKeyboard(chatId); // Show the main menu again
  
  }else if (data === 'add_new_unit') {
    addNewUnit(chatId);

  } else if(data.startsWith('room_')){
      room_index = data.split('_')[1];
      handleRoomOptionSelection(chatId, room_index);
  }else if (userData[chatId].currentStep === 'socket_selection') {
        socket_index = data.split('_')[1];
        handle_socket_selection(socket_index, chatId);
  } else if (userData[chatId].currentStep === 'polarity_test') {
      if (data === 'polarity_correct') {
          userUnits[chatId][userData[chatId].currentUnit].rooms[userData[chatId].currentRoom].sockets[userData[chatId].currentSocket].pol = 1;
      } else if (data === 'polarity_incorrect') {
          userUnits[chatId][userData[chatId].currentUnit].rooms[userData[chatId].currentRoom].sockets[userData[chatId].currentSocket].pol = 0;
      }else if(data === "return_to_socket_menu"){
        handleRoomOptionSelection(chatId, userData[chatId].currentRoom)
        return
      }
      y = parseInt(userData[chatId].currentSocket) + 1
      bot.sendMessage(chatId, `Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒÙˆØ³ØªÚ¯ÛŒ Ù¾Ø±ÛŒØ² ${y}Ø±Ø§ ÙˆØ§Ø±Ø¯ Ù†Ù…Ø§ÛŒÛŒØ¯`).then(() => {
          userData[chatId].currentStep = 'enter_con_value';
        });
      
    }
  });










function save_user_information(msg){
    const chatId = msg.chat.id;
    const firstName = msg.chat.first_name;
    const lastName = msg.chat.last_name;
    
    // Save user information
    userData[chatId] = {
        userId: chatId,
        firstName: firstName,
        lastName: lastName,
        ownerName: null,
        engineerName: null,
        electricianName: null,
        address: null,
        unitMsgId: null, // Store the message ID for updating keyboard later
        currentUnit:1,
        currentRoom:1,
        currentSocket:1,
        currentSockets : []
    };
    
    userUnits[chatId] = []
    // Initialize units for the user
    unit = 
    {
    number : 1,
    name : "1 ÙˆØ§Ø­Ø¯",
    rooms : []
    }

    for (let i = 0; i < rooms.length; i++) {
    room = {
        id: rooms[i][0],
        name: rooms[i][1],
        sockets: [{"pol" : NaN, "con" : NaN, "rcd": NaN, "loop" : NaN}]
    };
    unit.rooms.push(room);
    }

    userUnits[chatId].push(unit);

    
    // Start the data collection process
}

// Function to generate a keyboard layout
function generateKeyboardLayout(units) {
  const keyboard = [];
  for (let i = 1; i <= units.length; i++) {
    keyboard.push([{ text: `ÙˆØ§Ø­Ø¯ ${i}`, callback_data: `unit_${i}` }]);
  }
  keyboard.push([{ text: 'Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† ÙˆØ§Ø­Ø¯ Ø¬Ø¯ÛŒØ¯', callback_data: 'add_new_unit' }]);
  return keyboard;
}

// Function to generate the detailed room options keyboard
function generateRoomOptionsKeyboard() {
    x = []
    for(i = 0; i < rooms.length; i++){
        x.push([{ text: rooms[i][1], callback_data: "room_" + i }])
    }
    x.push([{ text: 'ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§Ù†ØªØ®Ø§Ø¨ ÙˆØ§Ø­Ø¯', callback_data: 'return_to_units' }])
    return x;
}

// Function to show main keyboard with buttons
function showUnitsKeyboard(chatId) {
  const keyboard = generateKeyboardLayout(userUnits[chatId]);

  bot.sendMessage(chatId, `ğŸŸ¢*Ù„Ø·ÙØ§Ù‹ ÛŒÚ© ÙˆØ§Ø­Ø¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:*`, {
    reply_markup: {
      inline_keyboard: keyboard
    }, parse_mode: 'MarkdownV2'
  }).then((sentMessage) => {
    userData[chatId].unitMsgId = sentMessage.message_id; // Store the message ID for updating later
    currentKeyboards[chatId] = keyboard; // Store the initial keyboard for comparison
  });
}



// Function to handle unit selection
function handleUnitSelection(chatId, unitId) {
    userData[chatId].currentUnit = unitId;
    bot.sendMessage(chatId, `âœ…Ø´Ù…Ø§ ÙˆØ§Ø­Ø¯ ${unitId + 1} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯ÛŒØ¯.`);

    // Show detailed room options
    setTimeout(()=>{bot.sendMessage(chatId, 'ğŸŸ¢*Ù„Ø·ÙØ§Ù‹ Ù†ÙˆØ¹ ÙØ¶Ø§ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯*', {
    reply_markup: {
        inline_keyboard: generateRoomOptionsKeyboard()
    }, parse_mode: 'MarkdownV2'
    });}, 500)
}

function generateSocketSelectionKeyboard(chatId) {

    sockets = userUnits[chatId][userData[chatId].currentUnit].rooms[userData[chatId].currentRoom].sockets
    
    x = []
    for(i = 0; i < sockets.length; i++){
        x.push([{ text: 'Ù¾Ø±ÛŒØ²' + (i + 1), callback_data: 'socket_' + i }])
    }
    x.push([{ text: "ğŸ”™Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§Ù†ØªØ®Ø§Ø¨ ÙØ¶Ø§", callback_data: "return_to_room_selection" }])
    return x;
  }

// Function to handle room option selection
function handleRoomOptionSelection(chatId, room_index) {
  userData[chatId].currentRoom = room_index;
    bot.sendMessage(chatId, '*Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ù¾Ø±ÛŒØ² Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯*', {
        reply_markup: {
          inline_keyboard: generateSocketSelectionKeyboard(chatId)
        }, parse_mode: 'MarkdownV2'
      }).then(() => {
        userData[chatId].currentStep = 'socket_selection';
      });
}

// Function to add a new unit
function addNewUnit(chatId) {
    // Get the next unit number
    const newUnitNumber = userUnits[chatId].length + 1;
    unit = 
    {
    number : newUnitNumber,
    name : "ÙˆØ§Ø­Ø¯" + newUnitNumber,
    rooms : []
    }

    for (let i = 0; i < rooms.length; i++) {
    room = {
        id: rooms[i][0],
        name: rooms[i][1],
        sockets: [{"pol" : NaN, "con" : NaN, "rcd": NaN, "loop" : NaN}]
    };
    unit.rooms.push(room);
    }


    // Update units for the user
    userUnits[chatId].push(unit)
    showUnitsKeyboard(chatId)

    

    // // Create a new keyboard with updated buttons
    // const newKeyboard = generateKeyboardLayout(userUnits[chatId]);

    // bot.editMessageText('Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ú¯Ø²ÛŒÙ†Ù‡ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:', {
    //     chat_id: chatId,
    //     message_id: userData[chatId].unitMsgId,
    //     reply_markup: {
    //     inline_keyboard: newKeyboard
    //     }
    // }).catch(error => {
    //     // Log the error if the message couldn't be updated
    //     console.error('Error updating message:', error);
    // });

    // // Update the stored keyboard
    // currentKeyboards[chatId] = newKeyboard;
  
}

function handle_socket_selection(socket_index, chatId){
  userData[chatId].currentSocket = socket_index;
        bot.sendMessage(chatId, 'ØªØ³Øª Ù¾Ù„Ø§Ø±ÛŒØªÙ‡ Ù¾Ø±ÛŒØ²' + parseInt(socket_index + 1), {
            reply_markup: {
                inline_keyboard: [
                [{ text: 'âœ… Ø¯Ø±Ø³Øª', callback_data: 'polarity_correct' }],
                [{ text: 'âŒ Ù†Ø§Ø¯Ø±Ø³Øª', callback_data: 'polarity_incorrect' }],
                [{ text: 'ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù¾Ø±ÛŒØ²', callback_data: 'return_to_socket_menu' }]
                ]
            }
            }).then(() => {
            userData[chatId].currentStep = 'polarity_test';
            });
}



// Convert JSON to a format suitable for Excel
function jsonToExcelData(data) {
  const rows = [];

  // Iterate over each unit
  data.forEach((unit) => {
    // For each room in the unit
    unit.rooms.forEach((room) => {
      // For each socket in the room
      room.sockets.forEach((socket, index) => {
        if(!isNaN(socket.con))
          rows.push({
            UnitName: unit.name,
            RoomName: room.name,
            SocketIndex: index + 1,
            Polarization: socket.pol ? 'Yes' : 'No',
            Continuity: socket.con,
            RCD: isNaN(socket.rcd) ? '-' : socket.rcd,
            Loop: isNaN(socket.loop) ? '-' : socket.loop,
          });
      });
    });
  });

  return rows;
}


//////////////////////////////////


function askOwnerName(chatId) {
  bot.sendMessage(chatId, 'âœï¸ *Ù†Ø§Ù… Ù…Ø§Ù„Ú© Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯*', { parse_mode: 'Markdown' });
  bot.once('message', (msg) => {
    const response = msg.text;
    if(response == 'Ø´Ø±ÙˆØ¹ Ù…Ø¬Ø¯Ø¯' || response == 'Ø®Ø±ÙˆØ¬ÛŒ Ø§Ú©Ø³Ù„' || response == '/start')
      return
    console.log("dfsdfsd")
    if (response && response.trim()) {
      userData[chatId].ownerName = response.trim();
      askEngineerName(chatId);
    } else {
      bot.sendMessage(chatId, 'âš ï¸ Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.');
      askOwnerName(chatId);
    }
  });
}

// Function to ask engineer name
function askEngineerName(chatId) {
  bot.sendMessage(chatId, 'âœï¸ *Ù†Ø§Ù… Ù…Ù‡Ù†Ø¯Ø³ Ù†Ø§Ø¸Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯*', { parse_mode: 'Markdown' });
  bot.once('message', (msg) => {
    const response = msg.text;
    if(response == 'Ø´Ø±ÙˆØ¹ Ù…Ø¬Ø¯Ø¯' || response == 'Ø®Ø±ÙˆØ¬ÛŒ Ø§Ú©Ø³Ù„' || response == '/start')
      return
    if (response && response.trim()) {
      userData[chatId].engineerName = response.trim();
      askElectricianName(chatId);
    } else {
      bot.sendMessage(chatId, 'âš ï¸ Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.');
      askEngineerName(chatId);
    }
  });
}

// Function to ask electrician name
function askElectricianName(chatId) {
  bot.sendMessage(chatId, 'âœï¸ *Ù†Ø§Ù… Ø¨Ø±Ù‚Ú©Ø§Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯*', { parse_mode: 'Markdown' });
  bot.once('message', (msg) => {
    const response = msg.text;
    if(response == 'Ø´Ø±ÙˆØ¹ Ù…Ø¬Ø¯Ø¯' || response == 'Ø®Ø±ÙˆØ¬ÛŒ Ø§Ú©Ø³Ù„' || response == '/start')
      return
    if (response && response.trim()) {
      userData[chatId].electricianName = response.trim();
      askAddress(chatId);
    } else {
      bot.sendMessage(chatId, 'âš ï¸ Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.');
      askElectricianName(chatId);
    }
  });
}

// Function to ask address
function askAddress(chatId) {
  bot.sendMessage(chatId, 'âœï¸ *Ø¢Ø¯Ø±Ø³ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯*', { parse_mode: 'Markdown' });
  bot.once('message', (msg) => {
    const response = msg.text;
    if(response == 'Ø´Ø±ÙˆØ¹ Ù…Ø¬Ø¯Ø¯' || response == 'Ø®Ø±ÙˆØ¬ÛŒ Ø§Ú©Ø³Ù„' || response == '/start')
      return
    if (response && response.trim()) {
      userData[chatId].address = response.trim();
      showSummary(chatId);
    } else {
      bot.sendMessage(chatId, 'âš ï¸ Ù„Ø·ÙØ§Ù‹ Ø¢Ø¯Ø±Ø³ Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.');
      askAddress(chatId);
    }
  });
}

// Function to show summary
function showSummary(chatId) {
  const data = userData[chatId];
  const summary = `
*Ù…Ø´Ø®ØµØ§Øª*

ğŸ¤µâ€â™‚ï¸ *Ù…Ø§Ù„Ú©:* ${data.ownerName}
ğŸ‘¨â€ğŸ’¼ *Ù…Ù‡Ù†Ø¯Ø³ Ù†Ø§Ø¸Ø±:* ${data.engineerName}
ğŸ”Œ *Ø¨Ø±Ù‚Ú©Ø§Ø±:* ${data.electricianName}
ğŸ  *Ø¢Ø¯Ø±Ø³:* ${data.address}

`;

  bot.sendMessage(chatId, summary, { parse_mode: 'Markdown' });

  // Show the unit selection menu
  setTimeout(()=>{showUnitsKeyboard(chatId);}, 500)
  
}

